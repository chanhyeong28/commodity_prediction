---
alwaysApply: true
description: Knowledge Graph schema and GraphRAG retrieval rules for commodity forecasting with SQLite + NetworkX
---

# Knowledge Graph and GraphRAG Rules

This rule defines the canonical knowledge graph (KG) schema, SQLite layout, and retrieval/scoring policy for our commodity forecasting system. It standardizes how patches, entities, and relationships are represented and queried during training and inference.

## Node Types

- TS_PATCH
  - Meaning: A time-series window embedding (patch) for any instrument.
  - Attributes:
    - node_id: string (unique)
    - series_id: string (e.g., LME_AL_Close, JPX_Gold_Close, US_Stock_VT_adj_close, FX_USDJPY)
    - exchange: string in {LME, JPX, US, FX}
    - instrument: string (parsed from column name or target_pairs)
    - window_start: date_id (int or ISO date string)
    - window_end: date_id
    - window_size: int (days; default 7, but dynamic multi-window allowed: {7, 14, 28})
    - stride: int (days; allow overlap e.g., 1–3)
    - embedding: vector (stored as BLOB in SQLite; float32)
    - stats_json: JSON (mean, std, skew, kurtosis, trend_slope, volatility)
    - regime_label: string (e.g., NORMAL, HIGH_VOL, TREND_UP, TREND_DOWN)
    - created_at: timestamp

- VAR
  - Meaning: Variable/instrument metadata node
  - Attributes: series_id, exchange, instrument, unit, frequency

- ENTITY_DATE
  - Meaning: Trading day metadata node
  - Attributes: date_id, weekday, is_holiday_by_exchange, month, quarter, year

- ENTITY_MARKET
  - Meaning: Market/exchange node
  - Attributes: market_id (e.g., LME, JPX, US, FX), timezone

- ENTITY_INSTRUMENT
  - Meaning: Instrument-level metadata node
  - Attributes: instrument_id, sector, commodity_family, currency

- ENTITY_REGIME
  - Meaning: Learned/detected regime node
  - Attributes: regime_id, regime_type, detection_method, score

## Edge Types

- POSITIVE_CORR(source=TS_PATCH, target=TS_PATCH)
  - weight: float in [0,1]
  - lag: int (days)
  - p_value: float
  - window_size: int (correlation window used)

- NEGATIVE_CORR(source=TS_PATCH, target=TS_PATCH)
  - Same attributes as POSITIVE_CORR

- COINTEGRATED(source=TS_PATCH, target=TS_PATCH)
  - test_stat: float
  - p_value: float

- TEMPORAL_NEXT(source=TS_PATCH, target=TS_PATCH)
  - Meaning: Sequential patch linkage within the same series
  - gap_days: int

- MARKET_RELATION(source=ENTITY_INSTRUMENT, target=ENTITY_MARKET)
  - relation: LISTED_ON

- HAS_DATE(source=TS_PATCH, target=ENTITY_DATE)
  - relation: ON_DATE (use window_end)

- BELONGS_TO(source=TS_PATCH, target=ENTITY_INSTRUMENT)
  - relation: OF_INSTRUMENT

- SAME_SERIES(source=TS_PATCH, target=VAR)
  - relation: OF_SERIES

## SQLite Layout (authoritative on disk)

Tables (minimum):

```sql
CREATE TABLE IF NOT EXISTS ts_nodes (
  node_id TEXT PRIMARY KEY,
  series_id TEXT,
  exchange TEXT,
  instrument TEXT,
  window_start INTEGER,
  window_end INTEGER,
  window_size INTEGER,
  stride INTEGER,
  embedding BLOB,
  stats_json TEXT,
  regime_label TEXT,
  created_at TEXT
);

CREATE TABLE IF NOT EXISTS ts_edges (
  source_node TEXT,
  target_node TEXT,
  relation_type TEXT,
  weight REAL,
  lag INTEGER,
  p_value REAL,
  test_stat REAL,
  window_size INTEGER,
  gap_days INTEGER
);

CREATE TABLE IF NOT EXISTS entities (
  entity_id TEXT PRIMARY KEY,
  entity_type TEXT,     -- DATE, MARKET, INSTRUMENT, VAR, REGIME
  attrs_json TEXT
);

CREATE INDEX IF NOT EXISTS idx_ts_nodes_series ON ts_nodes(series_id);
CREATE INDEX IF NOT EXISTS idx_ts_nodes_end ON ts_nodes(window_end);
CREATE INDEX IF NOT EXISTS idx_edges_type ON ts_edges(relation_type);
CREATE INDEX IF NOT EXISTS idx_edges_src ON ts_edges(source_node);
CREATE INDEX IF NOT EXISTS idx_edges_tgt ON ts_edges(target_node);
```

Notes:
- Embeddings are float32 arrays serialized to BLOB. Use a consistent endian and length prefix or fixed-length per dimension.
- All patches from all series live in the same embedding space.
- Generate dynamic windows: {7, 14, 28} with overlap (stride ∈ {1, 3, 7}).
- Entities extracted from `kaggle_data/train.csv` column names and `kaggle_data/target_pairs.csv`.

## Extraction Rules

- series_id parsing
  - Prefix to exchange mapping: {LME, JPX, US, FX}
  - Instrument name is the remainder after prefix and field suffix (e.g., `_Close`, `_adj_close`).

- target_pairs integration
  - For each target, parse `pair` and `lag`.
  - Record TARGET_LAG metadata by storing `lag` on correlation edges when applicable.

## Retrieval Policy (GraphRAG)

Objective: Given a forecasting query Q for target series S at date D with lookback W, retrieve a compact subgraph of relevant TS_PATCH nodes and connected entities.

Steps:
1) Seed embedding: compute the embedding for the latest patch of S ending at D (use W=7 by default; optionally also W in {14, 28}).
2) Candidate selection:
   - kNN by cosine similarity over `ts_nodes.embedding` (compute in Python/NumPy after fetching candidate rows by index filters: same exchange/instrument first, then global).
   - Time filter: prefer nodes with `window_end <= D`.
3) Graph expansion (1–2 hops):
   - Include neighbors via POSITIVE_CORR/NEGATIVE_CORR/COINTEGRATED edges (top N by |weight| or significance).
   - Add linked entities (ENTITY_MARKET, ENTITY_INSTRUMENT, ENTITY_DATE) for context.
4) Ranking score per node:

   score(node) = α·cos_sim(Q, node) + β·norm_edge_strength(node) + γ·market_match(node) + δ·recency_boost(node)

   - α ∈ [0.4, 0.7], β ∈ [0.1, 0.3], γ ∈ [0.05, 0.2], δ ∈ [0.05, 0.2]
   - market_match = 1.0 if same exchange/instrument family else 0.0
   - recency_boost = exp(−Δdays / τ), with τ ≈ 90

5) Budgeting:
   - Hard cap nodes ≤ 256 and edges ≤ 1024 to fit 16GB VRAM.
   - Prefer 60–80% TS_PATCH nodes, remainder entities.

6) Serialization for the model:
   - Linearize to compact JSON: list of {node_id, type, series_id, exchange, instrument, window_end, window_size, embedding, key stats, top edges}.
   - Down-project embeddings to D' (e.g., PCA to 64) before feeding to cross-attention to reduce memory.

## NetworkX Usage

- Load from SQLite at session start; do not persist back during inference.
- Compute centrality or simple degree weights for tie-breaking.
- Keep only last N months of patches in-memory if RAM bound (N configurable; default 24 months).

## Quality & Validation Checks

- Correlation edges: store p-values; drop edges with p > 0.1 to reduce noise.
- Cointegration edges: Johansen/Engle–Granger; record test_stat and p_value.
- Ensure TEMPORAL_NEXT edges only within identical series_id and contiguous windows.

## Performance Guidance

- Index-heavy filters first (series_id, window_end), then cosine similarity in Python/NumPy for top-K shortlists.
- Precompute and cache recent kNN for frequent target series during inference.
- Use float16 for model-side context tensors; keep SQLite BLOBs in float32 if needed for accuracy.

